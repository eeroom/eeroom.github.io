## java发展简史和基本概念
```
|----------|------------------|-----------------------------------------------------------------|
|   Year   |   Version        |                          Remark                                 |
|----------|------------------|-----------------------------------------------------------------|
|   1996   | java1.0          |   浏览器上java applet，类型于silverligth,flash，后期直接被禁用     |
|   1997   | java1.1          |   内部类                                                         |
|   1998   | java1.2          |   strictfp修饰符                                                 |
|          | java1.3          |                                                                 |
|          | java1.4(java sdk)|   断言，应用场景调整到服务端应用，生成html页面                      |
|   2004   | java5.0          |   泛型，元数据，枚举，foreach循环，自动装箱，注解                   |
|          | java6            |   增强类库                                                       |
|   2009   |                  |   oracle收购sun                                                  |
|   2011   | java7(jdk1.7)    |   简单改进                                                       |
|   2014   | java8(jdk1.8)    |   lambda,流和日期时间库                                           |
|   2017   | java9            |   模块化，版本号混乱终结了,java和jdk版本号一致，oracle jdk仅包含64位 |
|   2018   |                  |   每6个月一个大版本                                               |
|----------|------------------|-----------------------------------------------------------------|

java虚拟机=java解释器+jit即时编译
java 字节码文件 [-jar jar文件]
  %JAVA_HOME%\java.exe，启动java虚拟机，虚拟机执行目标文件中的字节码
  如果目标文件是.class文件，入口点就是该class的main方法
  如果目标文件是jar文件，则首先读取清单文件中Main-Class指定的class，入口点就是该class的main方法
  特别的：如果没有定义package,执行会话的目录没有限制，如果定义了package，则执行会话的目录必须是package目录结构的根目录
javac 源码文件
  java编译器，把源码文件xxx.java文件编译成字节码文件xxx.class
  特别的：源码文件的文件名必须和文件内的公共类名称保持一致
jshell，交互式的命令行工具，可以执行java代码，并且自动打印计算结果
  jdk包含一个jshell.exe的可执行文件，和java.exe可执行文件所在的目录相同，linux上jshell可执行文件没有exe后缀
包
  java使用包将类组织在一个集合中，借助包可以方便的组织自己的代码，确保类名的唯一性，假如两个程序员都建立了Empoloyee类，只要将这些放在不同的包中，就不会产生冲突
  为了保证包名的绝对唯一性，要用一个英特网域名（这显然是唯一的）以逆序的形式作为包名，然后对于不同的工程使用不同的子包
  特别的：类的完全限定名=包名+类名，从编译器的角度看，嵌套的包名之间没有任何关系，例如java.util包和java.util.jar包毫无关系，每个包都是独立的类集合
  c#中的等价概念是命名空间，如果命名空间仍然冲突，可以为不同程序集指定别名，然后利用别名来体现类的完全限定名
自定义包
  将包的名字放在源文件的开头
  将源文件放到与完整包名匹配的子目录中
  将编译后的类文件和源文件放在同一个目录中
  如果没有在源文件中放置package语句，这个源文件中的类就属于无名包，无名包没有包名
  特别的：编译器在编译源文件的时候不检查目录结构，
    如果代码中声明的包名和源代码文件实际的目录结构不一致，并且它也不依赖其他的包，能编译成功，但是运行时报错，虚拟机找不到类
  解决办法：将类文件移到代码声明的包名对应的路径中，否则，虚拟机就找不到类
  总结：类路径必须与包名匹配，这是jdk的约定，从1.2版开始，jdk的实现者修改了类加载器，明确禁止加载包名以java.开头的用户自定义的类
xxx.jar
  包含一个或多个类文件的java归档文件，本质就是zip格式的压缩文件
jar cvf jar文件名称 类文件1 类文件2
  创建一个jar文件
  清单文件，约定存放在特定目录：jar文件/META-INF/MANIFEST.MF
```
## 输入和输出
```
System.out.println()
  格式化输出，System.out.println("姓名：%2$s，年龄：%1$d，%1$d",121,"张三");
  %[索引值$][,(5.2f 转换浮点数][d 转换整数][s 转换字符串][c 转换日期时间]
  特别的，索引值从1开始
  String msg=String.format("姓名：%2$s，年龄：%1$d，%1$d",121,"张三");
var scanner=new Scanner(System.in);
var value=scanner.nextLine();
  输入
var console=System.console();
var value= console.readLine("请输入用户名:");
var pwd=console.readPassword("请输入密码:");
  输入，和c#的System.Console.WriteLine()和System.Console.ReadLine()类似
  特别的：在IDEA直接运行console是null，由cmd启动则正常，readPassword可以隐藏输入的字符
简单读取和写入文本文件
var scanner=new Scanner(Path.of("D:\\vs2019启动没反应.txt"),"GBK");
try (var printWriter=new java.io.PrintWriter(new File("D:\\vs2019启动没反应UTF-8.txt"),"UTF-8")){
    while (scanner.hasNext()){
        printWriter.println(scanner.nextLine());
    }
}
```
## 对象与类
```
面向过程编程，先考虑算法，再考虑数据结构，算法+数据结构=程序
面向对象编程，先考虑数据结构，再考虑算法，数据结构+算法=程序，特征：封装+继承+多态
类
  构造对象的模板，类之间的关系：依赖，聚合，继承
  c#中区分值类型和引用类型，java没有这个划分
对象
  类的实例，对象的三个主要特征：行为，状态，标识
  变量等价于c++的一级指针，指向一个对象；和c++的引用不一样
  null值处理，Objects提供一些便捷方法，java9引入
  Objects.requireNonNull(变量,"变量值不能为null")
  Objects.requireNonNullElse(变量,变量默认值)等价于c#的??运算符
实例字段
  字段可以不明确复制，如果构造函数没用显式地为字段赋值，编译器会自动地赋上默认值，值类型为0，布尔类型为false，对象引用为null
静态字段
  又称为类字段
静态常量
  final修饰的静态字段
  public static final double PI=3.1415
  等价于c#:public static readonly double PI=3.1415
  或者：public const double PI=3.1415
  c#中const修饰的变量等价于static readonly，java中const是保留关键字，目前未使用
final
  修饰实例字段，等价于c#的readonly
  修饰静态字段，等价于c#的readonly，并且该静态字段成为静态常量
  修饰变量值，则变量不可以被重新赋值，类似于只读指针，c#没有等价的语法和机制
  修饰类，等价于c#的seal，类不能被继承
  修饰实例方法，则方法不能被重写，java默认所有public和protect方法都能重写，c#中必须使用virtual修饰的pubulic和protect方法才能被重写
abstract
  修饰类，抽象类，不能直接创建抽象类的实例
  修饰方法，抽象方法
实例方法
  关键字this指示隐式参数，实例.实例方法(参数值)等价于对应的静态方法:静态方法(实例,参数值),该对应的静态方法第一个参数名就是this
  面向对象语言在工程层面和源代码层面把数据结构和算法耦合，这个做法一般很符合人们对实际事物的理解和抽象
  源代码编译之后，数据结构和算法会分离，类的实例字段组合成数据结构，实例方法和静态方法成为算法，并且编译后没有实例方法，都是静态方法
  c#通过创建实例方法对应的静态方法的委托，从而验证编译后没有实例方法，都是静态方法
静态方法
  类名称.静态方法()   
  实例.静态方法()  符合语法，但是不建议这种调用方式
  c#中调用静态方法的方式：类名称.静态方法()
抽象方法
  只有定义，没有实现，非抽象的子类必须实现抽象方法
  接口的方法都是抽象方法，java8引入了默认方法，私有方法，静态方法
术语"静态"的历史
  C语言引入static为了表示退出一个块后依然存在的局部变量
  在这种情况下，术语"静态"是有意义的：变量一直保留，当再次进入这个块时变量仍然存在
  随后，static在C语言中有了第二种含义，表示不能从其他文件访问的全局变量和函数，为了避免引入新的关键字，所以重用了关键字static
  最后，C++第三次重用了这个关键字，与前面赋予的含义完全无关，它指示属于类而不属于实例的变量和函数
  java的static与c++中的static等价
变量
  变量必须被赋值后才可以使用，否则编译报错，java和c#对变量的这个规则是一致的
  var关键字声明局部变量，java10引入
  和字段的区别：变量是方法中的声明的变量，实例字段是类中声明的变量；变量指向某个具体的数据，字段是数据结构的组成部分
  Character.isJavaIdentifierStart()
    判断某个字符是否可以作为变量名的开头
  Character.isJavaIdentifierPart()
    判断某个字符是否可以作为变量名非开头的其他部分
  全局变量：C语言的概念，面向对象语言没有这个概念，但是类的公共静态字段和C语言的全局变量机制类似
常量
  值不变的变量
方法参数值的三种传递方式
  按值调用，方法参数得到的值是调用方法时变量值的副本，java中引用类型的变量本身就是一个一级指针，参数得到的是指针的副本，仍然指向同一个对象
  按引用调用，方法参数得到的值是调用方法时变量的指针
  按名调用，Algol语言使用这种机制
  java总是采用按值调用，java的参数有2种类别，基本数据类型和对象引用，对象引用本质就是一级指针，参数得到的是指针的副本，仍然指向同一个对象
  c#默认按值调用，如果参数使用ref或者out修饰，则变为按引用调用

8种基本类型(primitive type)
  |-----------|---------|-------------------------------------------------------------------------|
  |    type   |  length |    remark                                                               |
  |-----------|---------|-------------------------------------------------------------------------|
  |  byte     |  1字节  |  [-128,127]                                                             |
  |  short    |  2字节  |  [-32786,32767]                                                         |
  |  int      |  4字节  |  [-20亿,20亿]                                                            |
  |  long     |  8字节  |  []                                                                     |
  |  float    |  4字节  |  有效位数6到7位，对于一个非常接近0的值(小数点后面大于7个0)，float只能表示为0  |
  |  double   |  8字节  |  有效位数15                                                              |
  |  char     |  2字节  |                                                                         |
  |  boolean  |  1字节  |                                                                         |
  |-----------|---------|-------------------------------------------------------------------------|
三个特殊的浮点数
  Float.NaN                NaN
  Float.POSITIVE_INFINITY  正无穷
  Float.NEGATIVE_INFINITY  负无穷
  Double.NaN                NaN
  Double.POSITIVE_INFINITY  正无穷
  Double.NEGATIVE_INFINITY  负无穷
算术二元运算
  首先会把两个数据的数据类型转成一致，然后再进行计算
  如果除数是0，则异常
  如果除数是0d或者0f，结果是NaN或者无穷
  0d/0d=NaN
  0f/0f=NaN
  NaN==NaN的结果是false，js的浮点数也类似，判断一个值是否是NaN的正确做法：Double.isNaN(值)
char类型和Unicode
 'A'的Unicode码点是65，等价写法'\u0041'
  常用的转义
  |------|--------------|----------|
  | 转义 |     字符      |  Unicode |
  |------|--------------|----------|
  |  \b  |   退格       |  \u0008  |
  |  \t  |   制表       |  \u0009  |
  |  \r  |   回车       |  \u000d  |
  |  \n  |   换行       |  \u000a  |
  |  \"  |   "          |  \u0022  |
  |  \'  |   '          |  \u0027  |
  |  \\  |   \          |  \u005c  |
  |  \u  | 16进制表示字符|          |
  |      |    [         |  \u005B  |
  |      |    ]         |  \u005D  |
  |------|--------------|----------|
  转义会在代码解析之前处理，类似于宏的预处理，"\u0022+\u0022" 编译前被转为""+""，运行时的结果为""
  public static void main(String\u005B\u005D args) 可以编译通过，但IDEA会报红
  \u后边必须接4个16进制数，否则报错
  代码注释中如果有\u要特别注意，比如：// \u000a is a new line
  IDEA不会报红，但编译报错，原因：\u000a是换行符，导致is a new line实际在下一行，没有以//开头
  java采用16位Unicode字符集，char类型已经不能描述所有Unicode字符
  UTF-16编码采用不同长度的编码表示所有的Unicode码点，在第一个基本多语言平面，每个字符用16位表示，通常称为代码单元，char类型描述了UTF-16编码中的一个代码单元
  UTF-8编码采用不同长度的编码表示所有的Unicode码点，在第一个基本多语言平面，0-127用8位表示，
    整体的思路和UTF-16类似，就是字节本身的大小决定了其是属于哪一类（8位表示的值，16位表示的值，24位表示的值）
  UTF-8非常适合网页，html中的标签,以及js代码都是在[0-127]范围内，如果用UTF-16，体积翻倍
字符串类型
  StringBuilder
    和c#的StringBuilder是等价的，优先使用，java5引入
  StringBuffer
    StringBuilder的前身，和StringBuilder的区别，允许多线程进行添加和删除，两者的api是一致的
大数类型
  java.math.BigInteger
    可以处理任意序列长度的整数
  java.math.BigDecimal
    可以处理任意精度的浮点数
  java.math.BigInteger.valueOf(100)
    不能使用算术运算符，需要调用相应的方法，java仅重载的了字符串的+运算符，并且不允许重载运算符
数组类型
  int[] lst=new int[5];
  int[] lst2={1,2,3,4};
  int[] lst2=new int[]{1,2,3,4};
    初始化数组变量
    c#初始化数组语句：int[] lst3=new int[]{1,2,3,4};
  var str=java.util.Arrays.toString(lst2);
    获取数组内容对应的字符串
  int[][] lst2={数组1,数组2};
    多维数组，java实际没有多维数组，只有一维数组，多维数组被解释"数组的数组"
  var str= java.util.Arrays.deepToString(lst2);
    获取多维数组内容对应的字符串
  java.util.Arrays.sort
    快排
  java.util.Arrays.copyOf
    拷贝
  java.util.Arrays.binarySearch
    二分查找算法查找指定值，返回索引
  java.util.Arrays.fill
    填充指定值
  java.util.Arrays.equals
    根据数组内容判断数组是否相等，而非根据引用地址判断，具体逻辑：如果长度相同，并且相同索引的元素也相等，则两个数组相等
枚举类
  枚举的构造器总是私有的，可以省略private修饰符
  枚举的toString方法返回枚举常量名，和valueOf互为逆方法
  public enum Size{
    大(1),中(2),小(3);
    private Size(int value){
      this.value=value
    }
    int value;
  }
```
## 封装
```
封装
  数据和行为组合
  编译后，数据和行为分离
  访问器方法如果返回一个可变对象引用，意味着破坏封装性，可以返回改字段的clone对象，避免破坏封装
|--------------------|-----------------------------------|
|  方法访问控制修饰符  |           说明                    |
|--------------------|-----------------------------------|
|   private          |   仅本类可见                       |
|   默认，没有修饰符  |    仅对本包可见                     |
|   protected        |   仅对本包和子类可见                |
|   public           |   所有可见                         |
|--------------------|-----------------------------------|

|--------------------|-----------------------------------|
|方法访问控制修饰符(c#)|           说明                    |
|--------------------|-----------------------------------|
|   private          |   仅本类可见                       |
|   internal         |    仅所在程序集可见                 |
|   protected        |   仅子类可见                       |
|  protected internal|   仅子类和当前程序集可见            |
|   public           |   仅子类可见                       |
|--------------------|-----------------------------------|
```
## 继承
```
默认所有类可以被继承
不支持多重继承，原因是多重继承会语言变得复杂（c++）（虚基类，控制规则，横向指针）或者效率降低(Eiffel)
  C++允许一个类有多个超类
使用final修饰类，则类不能被继承，并且他的所有方法都被final修饰
c#默认所有类可以被继承，使用seal修饰符，则类不能被继承
子类->父类
子类->超类
派生类->基类

调用超类构造函数和超类的普通方法
public class Student extends People{
    string name;
    public Student(){
        super(101);
        this.name=super.getTag()+"|Student";
    }
}
c#调用父类构造函数父类的普通方法
public class Student:People{
    string name;
    public Student():base(101) {
        this.name=base.getTag()+"|Student";
    }
}
类型转换
  只能在继承层次内进行强制类型转换
  特别的，可以把任何变量转成Object类型，再转成其它类型，这样可以编译通过，但是运行可能会报错
obj instanceof 类型
  判断变量是否是指定类型的实例或指定类型的子类型的实例
  c#的等价操作:obj is 类型
数组的类型转换
  子类[] a=value;
  父类[] b=a;         编译通过，运行通过
  潜在的问题：
  b[0]=子类2实例      编译通过，运行通过
  a[0].子类1的方法()  编译通过，运行报错或者结果非预期
  特别的：
  int[]可以转为Object类型，但不能转为Object[]类型
  People[]可以转为Object类型，也能转为Object[]类型
可变长参数方法，本质是编译器把参数改为数组
  int max(String name,int... lst){
  }
  等价于
  int max(String name,int[] lst){
  }
  特别的：可变长参数最多只能有一个，而且是最后一个参数，可以直接把数组传给可变长参数
  max(1,2,3)编译器会转换为：max(new int[]{1,2,3})
  c#的可变长参数
  int Max(string name,params int[] lst){
  }
```
## 多态
```
所有方法默认可以重写，使用final修饰符，则方法不允许被重写，final类的所有实例方法都被final修饰
c#所有方法默认不可以重写，使用virtual修饰符，则方法允许被重写
c++所有方法默认不可以重写，使用virtual修饰符，则方法允许被重写
方法调用
  静态绑定，final修饰的方法，编译器都可以实现静态绑定，编译时可能对方法调用进行优化，内联，等价于把被调用方法的内容搬到调用的地方，减少一次方法调用
  动态绑定，非final方法需要虚拟机进行动态绑定，虚拟机在程序启动后会维护一份方法列表，可以根据方法签名快速匹配，虚拟机在运行时会进一步进行内联优化
```
## 接口、lambda表达式和内部类
```
接口
  一个类可以实现多个接口，效果和多重继承类似，同时避免多重继承的复杂性和低效性
  c#接口只能包含属性或者方法，属性的本质是方法
实例字段
  不能包含实例字段
常量
  可以包含常量，总是publick static final修饰的，声明的时候，不必提供这些关键字
抽象方法
  一般情况下，都是public的抽象方法，在接口中声明方法的时候，不必提供关键字public和abstract
静态方法
  java8引入，使用static修饰，理论上讲，没有任何理由认为这是不符合法的，只是这有违于将接口作为抽象规范的初衷
  java8以前，都是将静态工具方法放在伴随类中，在标准库中，你会看到成对出现的接口和实用工具类，
    如Collection和Collections,Path和Paths
  java11中，Path接口提供了一些静态方法，和Paths工具类中的静态方法等价，这样一来，Paths工具类就不再是必要的了
私有方法
  java9引入，使用private修饰，可以是实例方法或者静态方法，
  接口的私有方法只能在接口本身的方法中使用，只能作为接口中其他方法的辅助方法
默认方法
  java8引入，使用default修饰，可以为接口提供一个或多个默认实现，默认方法是public修饰的实例方法，不必提供关键字public
  作用：接口演化，默认情况下，A实现了接口I，如果I中新增了方法定义M，则A中必须实现M，才能编译通过
    把M增加defualt修饰符，并实现，则A可以不修改，不重新编译
默认方法冲突的处理原则
  如果父类的方法和父接口中的默认方法同名，则接口中的默认方法被忽略，称为类优先原则
  如果父接口1和父接口2中，存在相同方法签名的方法，只要存在至少一个默认方法，则继承类必须实现这个方法，否则编译不通过，编译器认为存在二义性
  如果父接口1和父接口2中，存在相同方法签名的抽象方法，则不存在冲突
lambda表达式
  (类型1 参数1[,类型2 参数2])->{do something;}
  一个可传递的代码块，可以在以后执行一次或多次
  java传递一个代码段并不容易，不能直接传递代码段，必须构造一个对象，这个对象的类需要有一个方法对应所需的代码段
  在其他语言中，可以直接处理代码块，java设计者长时间以来一直拒绝增加这个特性，直到支持lambda
    原因：java的强大之处就在于其简单性和一致性，倘如只要一个特性能够让代码稍简洁一下额，就把这个特性增加到语言中，那么这个语言很快就会变得一团糟，无法管理
函数式接口
  对于只有一个抽象方法的接口，这种接口称为函数式接口，可以添加@FunctionalInterface注解
  需要这种接口的对象时，可以提供一个lambda表达式
方法引用
  类似于lambda表达式，方法引用不是一个对象，不过，把方法引用赋值给一个函数是接口变量时会生成一个对象
  实例::实例方法名
    实例方法的方法签名与函数式接口的方法签名是一致的
    等价的lambda表达式:(参数1,参数2)->实例.实例方法名(参数1,参数2)
  类型::实例方法名
    实例方法的方法签名与函数式接口的方法签名不一致，函数式接口的方法需要在参数列表首部添加该实例方法的隐式参数
    等价的lambda表达式:(类型实例,参数1,参数2)->类型实例.实例方法名(参数1,参数2)
  类型::静态方法名
    静态方法的方法签名与函数式接口的方法签名是一致的
    等价的lambda表达式:(参数1,参数2)->类型.静态方法名(参数1,参数2)
  class Student{
    String say(Integer num){
      return num.toString();
    }
  }
  Student student=new Student();
  CsFunction2<Integer,String> handler11=student::say;
  CsFunction2<Integer,String> handler12=x->student.say(x);
  CsFunction3<Student,Integer,String> handler21=Student::say;
  CsFunction3<Student,Integer,String> handler22=(x,y)->x.say(y);
构造器引用
  类型::new
  本质就是方法引用，针对构造函数，
  int[]::new
  等价于的lambda表达式：x->new int[x]
  java不能构造泛型类型的T数组，表达式new T[n],不能编译通过，因为类型擦除，即使编译通过，也是new Object[n],导致运行时报错
  因为上述限制，var stream= Steam<Student>;
  stream.toArray()                  返回Object[]类型数组，可以从stream中取一个元素，反射得到类型，然后创建改类型的数组，实现返回Student[]
  stream.toArray(Student::new)      返回Student[]类型数组
  stream.toArray(x->new Student[x]) 返回Student[]类型数组
闭包和变量作用域
  lambda表达式可以捕获外围作用域中变量的值
    但是外围变量的值需要确保不能改变，这是java的限制，编译器创建包含lambda代码段的类型，对于引用的外围变量会创建对应的字段并赋值过去
    原因：如果lambda表达式中更改变量，并发执行多个动作时就会不安全
    绕过限制:定义一个包含字段的匿名对象，例如：var lp=new Object(){Integer age=10;};lambda表达式可以随意修改lp.age的值
    c#没有这种限制
  lambda在运行时，方法中的this变量指向定义lambada表达式的方法的this隐式参数，如果定义lambda方法的方法是静态方法，则lambda方法里面不能使用this
内部类
  定义在另一个类中的类，java语言规范约定：不能有静态方法，静态字段必须使用finale修饰
  编译器会自动修改内部类的构造函数，增加一个内部类所在类的类型的参数，
  编译器会自动修改创建内部类实例的代码，传递this作为内部类构造函数的第一个参数值
  可以使用private修饰，其他类只能public修饰，或者没有修饰符(默认，包可见)
  编译器将会把内部类转换为常规的类文件，用$分隔外部类名与内部类名，而虚拟机对此一无所知
  内部类可以访问外部类实例私有字段和私有方法：外部类.this.私有方法()
    原理：编译器会在外部类中添加对应的静态方法，参数是外部类实例，返回值就是该字段值
         内部类获取外部类实例私有字段的语句会被改为调用这个外部类的静态方法
         总之，私有字段仍然只有字段所属类能够访问，封装特性对于内部类访问外部类实例私有字段这种情况仍然成立
  java支持内部类的原因：
    内部类可以对同一个包中的其他类隐藏
    内部类可以访问定义这个类的作用域中的数据，包括原本私有的数据
    内部类对于简洁地实现回调非常重要，不过如今lambda表达式在这方面可以做得更好，但内部类对于构建代码还是很有用的
创建内部类实例
  new 内部内构造函数(参数,参数)
    等价于：this.new 内部内构造函数(参数,参数)
  外部类实例.new 内部内构造函数(参数,参数)
  特别的：外部类实例可以是this，也可以是其他实例
  外部类的静态方法里面不能使用简写创建内部类的实例，因为静态方法没有this参数
局部内部类
  定义在一个方法中的类，不能添加访问修饰符，局部类的作用域被限定在声明这个局部类的方法块中
  可以访问所在方法的局部变量，但是局部变量必须是事实最终变量，这和lambda外围变量的限制是一样的
    原理：局部内部类会创建这个局部变量对应final修饰的字段并赋值过去
  优势：对外部世界完全隐藏，除了所在方法之外，没有任何方法知道这个类的存在
匿名内部类
  new 接口或类(构造函数参数){}
  定义在一个方法中的类，比局部内部类再进一步，不指定类名字
  不能有构造函数，因为构造函数的名字必须和类名相同，但匿名内部类没有类名
  仍然可以有对象初始化块，效果和构造函数一样，var lst=new ArrayList<String>(){{add("1");add("2)}};
    双括号初始化，利用了匿名内部类的语法，双括号，外层括号建立ArrayList的一个匿名子类，内层括号是一个对象初始化块
    实际上，这个技巧很少使用，等价的做法，List.of(....)
  场景：匿名内部类实现事件监听器和回调函数，java8以后可以使用lambda表达式
静态内部类
  使用static修饰的内部类
  等价于c#的内部类，和所在的外部类完全独立，和普通的类一样
  c++嵌套类等价于静态内部类
  特别的：接口中声明的内部类自动是public和static
常见的一些接口如下：
public interface java.lang.Comparable<T> {
  /**
  约定：返回值体现this和target的比较结果
  返回值等于0，表示this==target
  返回值>0，表示this>target
  返回值<0，表示this<target
  /
  int compareTo(T target);
}
public interface Comparator<T> {
  /**
  约定：返回值体现o1和o2的比较结果
  返回值等于0，表示o1==o2
  返回值>0，表示o1>o2
  返回值<0，表示o1<o2
  /
  int compare(T o1, T o2);
}
Arrays.sort(lst,Comparator.<Integer,String>comparing(x->x.toString(),
    Comparator.nullsFirst(Comparator.naturalOrder())).thenComparing(Integer::byteValue));
Integer.compare(v1,v2)
  比较两个整数的大小，如果v1是一个很小的负值，v2是一个很大正值，直接使用v1-v2，结果可能溢出，导致非预期的结果
  另一种解决办法：利用语言的逻辑运算符来判断，var rt=v1>v2;如果rt是true就表示v1>v2是成立的
Double.compare(v1,v2)
  比较两个浮点数的大小，如果v1和v2非常接近，直接使用v1-v2的结果可能是0，导致非预期的结果
  另一种解决办法：利用语言的逻辑运算符来判断，var rt=v1>v2;如果rt是true就表示v1>v2是成立的
/**
 标记接口，没有定义方法
 Object类中定义了protected Object clone()方法，实现了浅拷贝：逐个字段进行拷
 如果原对象的字段都是数值或者其他基本类型，浅拷贝没有问题
 如果字段引用其他对象，拷贝字段就会得到相同对象的另一个引用，导致原对象和克隆对象共享一些信息
 如果字段引用的对象是不可变的，浅拷贝也没有问题
 但更多的情况是，引用的对象是可变，这时浅拷贝就有问题，必须重新定义clone方法来建立一个深拷贝
/
public interface java.lang.Cloneable {
}
javax.swing.Timer
```
## 泛型和反射
```
实例.getClass()
  获取实例的类型的元数据
T.class
  获取类型的元数据
java.lang.Class.from('类的完全限定名')
  获取指定类型的元数据
java.lang.reflect.Modifier.isFinal(T.class.getModifiers())
  获取类的修饰符信息
java.lang.reflect.Modifier.isStatic(T.class.getDeclaredField("").getModifiers())
  获取字段的修饰符信息
java.lang.reflect.Modifier.isPublic(T.class.getDeclaredMethod("").getModifiers())
  获取方法的修饰符信息
T.class.getFields()
  返回类支持的公共字段，包括超类的公共字段
T.class.getDeclareFields()
  返回类中的全部字段，包括私有、受保护的，不包括超类中的字段
T.class.getMethods()
  返回类支持的公共方法，包括超类的公共方法
T.class.getDeclaredMethods()
  返回类中的全部方法，包括私有、受保护的，不包括超类中的方法
T.class.getDeclareField("私有字段名称").setAccessible(true)
  覆盖指定字段的private访问控制，设置为public，这个特性是为调试，持久存储和类似机制提供的
  setAccessible方法可能会抛异常，原因是访问被模块系统或者安全管理器拒绝
  反射机制的默认行为受限于java的访问控制，对应于他的访问修饰符
T.class.getDeclaredMethod("私有方法名称").setAccessible(true)
  覆盖指定方法的private访问控制，设置为public
java.lang.reflect.Array.newInstance(T.class,100)
  利用反射，创建指定元素类型和长度的数组
java.lang.reflect.Array.getLength(lst)
  利用反射获取数组的长度
实例.class.getComponentType()
  获取数组元素的类型，专用方法
```
## SPI，服务加载器
```
jdk提供的一个加载服务的简单机制
第一步：服务定义，定义一个接口或者超类
第二部：服务提供者，定义一个或者多个实现了服务定义的类，实现类可以在任何包中，不需要和服务定义的包一致
第三部：把实现类的类名(完全限定名)放在约定的文件，约定文件：META-INF/services/类名称(完全限定名)
第四部：java.util.ServiceLoader.load(服务定义)，即可返回所有的服务
```
## 动态代理
```
代理，从jdk1.3开始的
创建代理的方法：Proxy.new ProxyInstance(类加载器，[被代理的一个或多个接口],调用处理器)
代理类实在程序运行时动态创建的，一旦被创建，就变成了常规类，
Class proxyClass=Proxy.getProxyClass(null,接口)
  获取动态创建的代理类
```
## 集合体系
```
长度可变，不能存储基本数据类型值
 |—--Collection（不同步,单列）
 |          |---List（有序，可以重复添加，迭代器遍历得到的数据顺序和数据的写入顺序一致或一一对应）
 |          |    |---ArrayList 基于数组结构实现，按下标查询效率高，增删非尾部的数据需要移动数组内的数据，效率不高
 |          |    |---LinkedList 基于链表结构，每个节点都包含本身的数据应用和前后两个节点的引用，按下标查询需要遍历节点，效率不高，增删数据效率高
 |          |---Set（无序，不能重复添加，迭代器遍历得到的数据顺序和数据的写入顺序一致）
 |               |---HashSet 基于HashMap实现，数据本身决定了其位置，把哈希值映射到数组索引值
 |               |---TreeSet 基于二叉树结构，数据按照比较接口的接口有序的分布在二叉树节点，这个有序是指数据排序，不是集合数据的添加顺序
 |               |---LinkedHashSet 基于hashmap?，并且数据包一层链表结构?
 |---Map（不同步，双列，key不能重复，但是value可以重复）
 |     |---HashMap ，基于哈希算法
 |     |---TreeMap
 |
 |---Vector(jdk1.0,同步，功能类似于ArrayList，已过时，兼容老代码，所以保留)
 |---Hashtable(jdk1.0,同步，功能类似于HashSet,已过时，兼容老代码，所以保留)
 |---Enumeration（枚举器，jdk1.0，已过时，新的jdk增加功能可直接转为迭代器）
 |---Iterator<E>（迭代器，取代枚举器）
```
## 多线程
```
```
## java8的流库
```
```
## xml
```
```
## 网络
```
```
## JDBC
```
```
## 日期和时间API
```
java的java.util.Date类实例表示一个特定的时间点，本质是距离UTC1970年1月1日00:00:00的毫秒数
UTC 国际协调时间
GMT 格林尼治时间
java.time.LocalDate对应日历表示法表示的日期，1.8新增的
java.time.LocalDate.now()
java.time.LocalDate.of(2022,12,22)
```
## 国际化
```
```
## java模块系统
```
```
## 安全
```
```
## 本地方法
```
```
##  进制和整数
```
二进制、十进制、16进制互转
转为十进制：
  二进制的abcd等价于十进制的值为：a*2^3+b*2^2+c*2^1+d*2^0=Value
  十进制的abcd等价于十进制的值为：a*10^3+b*10^2+c*10^1+d*10^0=Value
  十六进制的abcd等价于十进制的值为：a*16^3+b*16^2+c*16^1+d*16^0=Value
从十进制转出：
  转为二进制，参照等式a*2^3+b*2^2+c*2^1+d*2^0=Value，问题转换为已知Value,反推a,b,c,d;并且a,b,c,d的取值范围都是[0,1]
    方法：a*2^3+b*2^2+c*2^1+d*2^0===2*(a*2^2+b*2^1+c*2^0)+d===Value，也就是说最低位的d就等于Value除以2的余数。
    对应的：a*2^2+b*2^1+c*2^0=Value'，同理，c就等于Value'除以2的余数
    依次同理下去，即可得到b,a的值
  转为十六进制，参照等式a*16^3+b*16^2+c*16^1+d*16^0=Value，问题转换为已知Value,反推a,b,c,d;并且a,b,c,d的取值范围都是[0,F]
    方法：a*16^3+b*16^2+c*16^1+d*16^0=Value===16*(a*16^2+b*16^1+c*16^0)+d===Value，也就是说最低位的d就等于Value除以16的余数。
    对应的：a*16^2+b*16^1+c*16^0=Value'，同理，c就等于Value'除以16的余数，
    依次同理下去，即可得到b,a的值
1个字节===8位2进制(2的8次方)===2位16进制（16的2次方）,也就是一个字节的数值范围大小是[0x00,0xFF]
java的byte是1个字节，但是最高位是符号位，所以数值范围变为[-0x7F,0x7F]
c#的byte也是1个字节，但是没有符号位，所以数值范围[0x00,0xFF],sbyte是有符号的，和java的byte等价
```
## 二进制的负数
```
计算机内存内容都是0或者1，如果把一段字节数据按照有符号的数值来解析,±符号改如何解决呢
统一约定：这一段字节数据最高位是符号位，如果符号位值为1就是负数，否则为正数
这既符合我们直觉，规则又非常简单，类似于10进制数在最高位引入±号
基于这个规则，00 00 01 10 就等价于+6，
那么-6等价的二进制序列是多少呢？10 00 01 10？这非常符合直觉，但是计算机内存中并没有采用这种规则！
原因:对两个整数(正数或者负数或者0)进行加法运算，加法电路让符号位直接参与加法计算，这样加法电路才能足够简单！
     如果加法电路额外考虑符号位，加法电路会变得复杂的多！
回到普通的加法计算(-6+6);如果按照直觉的-6二进制序列
    10 00 01 10
  + 00 00 01 10
    10 00 11 00
这结果就变成了-12，这明显不对，当然问题原因就在于我们让符号位直接参与了运算
结论：'负数二进制序列等价于把其对应正数二进制序列的最高位改成1'这个符合直觉的负数表示规则，不能满足让符号位直接参与运算的期望！
继续回到普通减法计算(0-6);
    00 00 00 00
  - 00 00 01 10
    11 11 10 10
非常激动,11 11 10 10是否就可以作为-6的二进制序列呢？答案是肯定的，而且计算机内存就是采用这种方式！
数学原理及证明待研究。。。
上述规则总结是：负数二进制序列等价于把其对应正数二进制序列求反再加1，就是对应正数的补码！
    00 00 01 10  6的原序列
    11 11 10 01  反码
  + 00 00 00 01
    11 11 10 10  补码

反直觉：对于一个字节的有符号整数
  01 11 11 11  最大值(127)
  10 00 00 00  最小值(-128) 
  00 00 00 01  1           
  11 11 11 11  -1
一个字节的有符号整数表示不了+128
如果需要计算-128+128，需要2个字节的有符号数
字节数变多，同等正数值只需要在左边补0，但同等负数值的二进制序列非常不一样了！
```
## 字符和字符集
```
字符集本质上就是字符和二进制序列(代码值)的对应关系集合，如unicode,GBK
字符编码本质上就是规定如何存储字符对应的二进制序列，如果utf-8,utf-16,GBK
所以最直接的字符编码方式就是直接存储字符对应的二进制值的序列，典型案例为GBK
但是有的字符编码方式是首先对二进制序列做处理，然后存储处理过后的二进制序列，典型案例为unicode字符集的utf-8编码
1991年发布Unicode1.0
Unicode字符集，代码值范围是[0x000000,0x10ffff]，使用3个字节，第1个字节代码平面标识，第2、3个字节是其真正的码值
分为17代码区（代码平面），每个区都可包含0xffff+1（65536）个字符,
代码区00：[0x000000,0x00ffff]
代码区01：[0x010000,0x01ffff]
代码区02：[0x020000,0x02ffff]
依次类推
代码区15：[0x0f0000,0x0fffff]
代码区16：[0x100000,0x10ffff]

todo gbk字符集

编码：把字符串和字符转成二进制数据进行存储或传输，需要指定具体的字符编码来确定如何存放每个字符的代码值
以utf-8为例,utf-8是根据每个字符代码值大小所在的区间范围决定使用多少字节来存储该代码值，各个区间范围下，都会在固定的位上填充固定值
    说明：?表示实际的unicode代码值存放位，其它的0、1表示utf-8规范规定的固定位固定值
    区间1：[0x000000,0x00007f] 1字节 0???????
    区间2：[0x000080,0x0007ff] 2字节  110????? 10??????
    区间3：[0x000800,0x00ffff] 3字节  1110???? 10?????? 10??????
    区间4：[0x010000,0x1fffff] 4字节  11110??? 10?????? 10?????? 10??????
    区间5：[0x200000,0x3fffff] 5字节  111110?? 10?????? 10?????? 10?????? 10??????
    区间6：[0x400000,0x7fffff] 6字节  1111110? 10?????? 10?????? 10?????? 10?????? 10??????
因为unicode规范的代码值只在范围[0x000000,0x10ffff]，也就是最高到对应到utf-8的区间4，所以我们说utf-8使用1到4个字节存储字符
比如字符'我'，unicode代码值为：0x6211,那么落在区间3,
0x6211对应的二进制值为：01100010 00010001
把0x6211的二进制值落到1110???? 10?????? 10??????上就变为：[1110]0110 [10]001000 [10]010001
落的规则：01100010 00010001从低位开始依次替换1110???? 10?????? 10??????中对应的?
验证：把[1110]0110 [10]001000 [10]010001 复制到windows的计算器二进制，再切换到十六进制可看到是E6 88 91
     在editpluas中输入'我'，按utf-8保存,然后编辑》16进制查看，也可以看到E6 88 91
乱码案例：中文'联通'按GBK字符集保存后字节数据刚好是110????? 10?????? 110????? 10??????结构，对应utf-8区间2。
重新用记事本、notepad++、editeplus等工具打开后它们会认为这是utf-8编码的文件，然后就乱码，改成按ANSI(windows上表示系统默认字符集，中文就是GBK)。

解码：解析字符串、字符的二进制数据的时候，需要指定具体的字符编码来确定字节数据对应的字符
以utf-8为例，解码的时候，首先逐字节读取。
    把读取到的该字节的值和utf-8区间去匹配，即可知道当前这个字符占了N（[1,4]）个字节，
    然后就可以把这N个字节都读取出来，然后把固定位固定值移除掉，剩下值的就是unicode代码值
    移除utf-8编码中的固定位置的固定值对应的位
    合并剩余的位成为一个或多个字节的值，合并规则和上面落规则互为逆操作
    继续从N个字节后开始逐字节读取

java代码源文件的编码格式可以是utf-8，gbk等，java编译器都可以识别
但是：如果javac运行时使用GBK编码解析文件内容，utf-8编码格式的.java文件包含中文就会编译报错，'编码GBK不可以映射的字符'
同理,如果javac运行时使用utf-8编码解析文件内容，gbk编码格式的源代码文件包含中文就会编译报错
cmd启动javac不加字符编码参数，那么javac就使用GBK编码解析文件内容，因为中文系统默认就是GBK编码
IDEA启动编译时会给javac加utf-8字符集参数，所以idea默认的文件编码格式是utf-8
javac -encoding utf-8 xxx.java

不论代码源文件是何种编码格式，编译后，源代码中的字符和字符串都被被转成utf-8编码后的二进制序列储到.class文件中
tips:可以写最2个简单的java文件，一个包含中文字符，一个包含数字字符，
    编译成.class文件后，以16进制查看.class文件，通过比对找到差异点，就可以发现中文字符、数字字符都是对应utf-8编码后的二进制序列

char类型占用2个字节，每个char实例的整数值对应unicode规范中该字符的代码值(特别：不包含代码区标识位后的代码值)
```
![效果图](./img/unicode代码平面.png)
![效果图](./img/unicode代码平面-BMP.png)
## 发布jar包到maven中心仓
```
注册sonatype账号，然后提第一次发jar包的issue到sonatype，按照指导完成后，sonatype会开通一个仓库给我们。
我的jar先发到sonatype仓，然后被同步到maven中心仓
项目的pom.xml引入sonatype和gpg相关的插件,参看sln项目的pom.xml和nalu项目的pom.xml
在maven的配置文件setting.xml中配置sonatype的账号和密码，如下图
```
![如图](./img/sonatype的账号配置.png)
```
需要把我们用来发布jar包的公钥发布到sonatype指定的公钥服务器，参看sonatype文档就好
gpg插件用私钥对jar包进行签名的时候，默认会使用gpg密钥列表里的第一对密钥，可以通过增加配置，指定特定的密钥对，如下图
```
![如图](./img/gpg配置01.png)
![如图](./img/gpg配置02.png)
```
gpg教程
生成密钥对：gpg --genkey
查看已有的密钥列表：gpg --list-keys
每个密钥对信息的第二行那一串guid值就是keyid
导出公钥：gpg -o 公钥导出后的保存的文件  --export key的id  -a
导出私钥：gpg -o 私钥导出后的保存的文件  --export-secret-keys key的id  -a
导出私钥的时候会跳出对话让我们输入私钥的密码！
导出约定：-a是可选的，标识是否使用ascii armor，不论公钥还是私钥，如果指定这个参数，导出的保存文件就用.asc结尾，如果不指定就用.gpg结尾
小技巧：如果加了-a参数，导出的文件可以直接以普通文本查看
导入公钥：gpg --import 公钥导出后的保存的文件
导入私钥：gpg --import 私钥导出后的保存的文件
完整教程请查看pdf文件
```
gpg完整教程文档[FAQ:](./page/gpg教程.pdf)
## jackson
```
var mapper=new com.fasterxml.jackson.databind.ObjectMapper()
mapper.setVisibility(PropertyAccesser.ALL,JsonAutoDetect.Visibility.ANY);
mapper.writeValueAsString(new Object(){int id=1;String name="zz";});
```
## 命令行参数
```
-D 添加的参数程序jvm的属性，-D属性名=属性值
  例如：java -Dserver.port=2200 -jar ./target/hello.jar
  特别的：-D要放在-jar前面，否则参数无效。对应为VM options
参数直接跟在命令后面
  例如：java -jar hello.jar 参数名=参数值 参数名2=参数值2
  参数就是jar包主启动类中main方法的args参数，按顺序来
-- springboot特有的方式，--key=value
  例如：java -jar ./target/hello.jar --server.port=2200
  特别的：也可以通过@Value("${server.port}")取到值
```
## Apache Guacamole
```
开源代理服务端+客户端
```