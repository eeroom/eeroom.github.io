# java--学习笔记

## hello world
```
假定源文件为hello.java,cmd会话的当前工作目录为d:/j20222/
hello.java文件里面定义了几个class,编译后就会有对应数量的xxx.class文件,编译器会把class的名称作为编译后的class文件的文件名，如果是嵌套class那么，会编译生成对应的 [父class名称]$[子class名称].class
场景一：在工作目录下建立hello.java,代码中不定义package,
    编译hello.java文件,注意点：javac hello.java；命令中必须有.java这个文件后缀
    执行入口类,注意点：java 入口类；命令不要包含.class这个文件后缀
场景二：在工作目录下新建hello.java,代码中定义package为io.github.eeroom.hz,
    编译hello.java文件
    执行入口类会报错,找不到类型
    解决办法:创建package对应的目录结构，把.class文件放到io/github/eeroom/hz/下,
    执行：java io/github/eeroom/hz/[入口类]
    注意点：把cmd会话工作目录切换到io/github/eeroom/hz,执行：java [入口类] 是会报错的，找不到类型
场景三：在工作目录新增子目录结构，io/github/eeroom/hz/，然后创建hello.java,定义package为io.github.eeroom.hz
    编译hello.java，以下2中方式都ok,并且编译后的.class文件都在io/github/eeroom/hz/下
    1、javac io/github/eeroom/hz/hello.java
    2、cmd会话工作目录切换到io/github/eeroom/hz目录，然后执行javac hello.java
    执行：java io/github/eeroom/hz/[入口类]
    注意点：把cmd会话工作目录切换到io/github/eeroom/hz,执行：java [入口类] 是会报错的，找不到类型
总结：执行的时候,被执行的class文件所在的物理路径和其代码中定义的package要一致,
     并且cmd会话的当前工作目录为其package定义结构对应的父级目录
```

##  进制基本数据类型
```
二进制、十进制、16进制互转
转为十进制：
    二进制的abcd等价于十进制的值为：a*2^3+b*2^2+c*2^1+d*2^0=Value
    十进制的abcd等价于十进制的值为：a*10^3+b*10^2+c*10^1+d*10^0=Value
    十六进制的abcd等价于十进制的值为：a*16^3+b*16^2+c*16^1+d*16^0=Value
从十进制转出：
    转为二进制，参照等式a*2^3+b*2^2+c*2^1+d*2^0=Value，问题转换为已知Value,反推a,b,c,d;并且a,b,c,d的取值范围都是[0,1]
        方法：a*2^3+b*2^2+c*2^1+d*2^0===2*(a*2^2+b*2^1+c*2^0)+d===Value，也就是说最低位的d就等于Value除以2的余数。
        对应的：a*2^2+b*2^1+c*2^0=Value'，同理，c就等于Value'除以2的余数
        依次同理下去，即可得到b,a的值
    转为十六进制，参照等式a*16^3+b*16^2+c*16^1+d*16^0=Value，问题转换为已知Value,反推a,b,c,d;并且a,b,c,d的取值范围都是[0,F]
        方法：a*16^3+b*16^2+c*16^1+d*16^0=Value===16*(a*16^2+b*16^1+c*16^0)+d===Value，也就是说最低位的d就等于Value除以16的余数。
        对应的：a*16^2+b*16^1+c*16^0=Value'，同理，c就等于Value'除以16的余数，
        依次同理下去，即可得到b,a的值

1个字节===8位2进制(2的8次方)===2位16进制（16的2次方）,也就是一个字节的数值范围大小是[0x00,0xFF]
java的byte是1个字节，但是最高位是符号位，所以数值范围变为[-0x7F,0x7F]
c#的byte也是1个字节，但是没有符号位，所以数值范围[0x00,0xFF]
```

## 字符和字符集
```
unicode是字符集规范，规定了每个字符对应的代码值（索引值）,代码值范围是[0x000000,0x10ffff]
分为17代码区，每个区都可包含0xffff+1（65536）个字符,
代码区00：[0x000000,0x00ffff]
代码区01：[0x010000,0x01ffff]
代码区02：[0x020000,0x02ffff]
依次类推
代码区15：[0x0f0000,0x0fffff]
代码区16：[0x100000,0x10ffff]
大多数的语言的字符都包含在0代码区，
utf-8,utf-16等是实现unicode规范的具体实现，规定了每个代码值的存储规则

char类型占用2个字节，每个char实例的整数值对应unicode规范中0代码区该字符的代码值(特别：不包含代码区标识位后的代码值)
程序运行时，字符变量的值、字符串的变量值在内存中都是unicode的代码值

把字符串和字符编码为具体的二进制数据进行存储或传输的时候，需要指定具体的字符集实现来确定如何存放每个字符的代码值
以utf-8为例,utf-8是根据每个字符代码值大小所在的区间范围决定使用多少字节来存储该代码值，各个区间范围下，都会在固定的位上填充固定值
    说明：?表示实际的unicode代码值存放位，其它的0、1表示utf-8规范规定的固定位固定值
    区间1：[0x000000,0x00007f] 1字节 0???????
    区间2：[0x000080,0x0007ff] 2字节  110????? 10??????
    区间3：[0x000800,0x00ffff] 3字节  1110???? 10?????? 10??????
    区间4：[0x010000,0x1fffff] 4字节  11110??? 10?????? 10?????? 10??????
    区间5：[0x200000,0x3fffff] 5字节  111110?? 10?????? 10?????? 10?????? 10??????
    区间6：[0x400000,0x7fffff] 6字节  1111110? 10?????? 10?????? 10?????? 10?????? 10??????
因为unicode规范的代码值只在范围[0x000000,0x10ffff]，也就是最高到对应到utf-8的区间4，所以我们说utf-8使用1到4个字节存储字符
比如字符'我'，unicode代码值为：0x6211,那么落在区间3,
0x6211对应的二进制值为：01100010 00010001
把0x6211的二进制值落到1110???? 10?????? 10??????上就变为：[1110]0110 [10]001000 [10]010001
落的规则：01100010 00010001从低位开始依次替换1110???? 10?????? 10??????中对应的?
验证：把[1110]0110 [10]001000 [10]010001 复制到windows的计算器二进制，再切换到十六进制可看到是E6 88 91
     在editpluas中输入'我'，按utf-8保存,然后编辑》16进制查看，也可以看到E6 88 91

解析字符串、字符的二进制数据的时候，需要指定具体的字符集实现来确定如何获取每个字符对应的代码值
以utf-8为例，解码的时候，逐字节读取。
    把读取到的该字节的值和utf-8区间去匹配，即可知道当前这个字符占了几个字节，
    然后就可以把这几个字节都读取出来，然后把固定位固定值移除掉，剩下值的就是unicode代码值
    移除固定值和组织unicode代码值规则和上面落规则互为逆操作
    依次读取后面的字符
```