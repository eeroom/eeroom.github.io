# net--学习笔记
## 整数-字符-二进制序列-十六进制序列
```
解析整数的规则：有符号的数，最高为符号位，最高位为0表示正数，最高位为1表示负数，无符号的数，不考虑符号位
把正数按有符号数转二进制序列的时候，最高位一定是0，体现在序列字符串上，高位前导的0都省略掉了
把负数按有符号数转二进制序列的时候，最高位一定是1
规律：对于一个负数，增加位数来表示等价的值，把所有增加的高位补1
     对于一个正数，增加位数来表示等价的值，把所有增加的高位补0
```
![效果图](./整数-字符-字节数组(整数数组)-字符串-二进制序列-十六进制序列.png)

## byte和sbyte互转
```
c#:byte为无符号整数，范围：[0-255][00-FF]，sbyte为有符号整数，范围[-128,127][80,7F]

java:byte为有符号整数，等价于c#的sbyte，java没有提供无符号的byte类型
已知无符号的byte值bv[0-255],获取其二进制序列对应的有符号的值：byte sbv=(byte) ((int)bv)
已知有符号的byte值sbv[-128,127],获取其二进制序列对应的无符号的值：
1、int bv= ((int) sbv) & 0xff;
2、int bv= Byte.toUnsignedInt(bv)
0xff就是0x000000ff，进行&运算，导致另一个计算数的高6位全部变为0,只剩下原有最低的2位保持原序列值。
((int) sbv) & 0xff的原理等价于下面的代码：
byte sbv=-3;
var str= Integer.toHexString(sbv);
var bv2=Integer.parseInt(str.replace("ffffff","000000"),16);
```

## 分布式和集群
```
现对于单机系统(应用程序,数据库等等都在一台服务器)而言,
一件具体的事情由多台不同的服务器共同完成，服务器之间存在协同；或者多台服务器可以无差别的处理同一件具体事情
依据看待事情的角度来确定怎样算一件具体的事情
用户修改密码，站在产品的功能点来看，可以看成一件事情，涉及应用程序，数据库，
站在代码处理流程的角度，也可以看成两件事情，1、http服务接收用户请求，2、数据库执行sql
对应的，把http接受用户请求搞成多台部署，就成了应用程序集群
把数据库部署多台,就成了数据库集群
所以集群一定是分布式部署，是一种特点情况下的分布式
```